\documentclass[a4paper, 1ppt]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage[german]{babel}
\usepackage{abstract}
\usepackage{url}
\usepackage{hyperref}
\usepackage{hyphenat}
\usepackage{minted}
\clubpenalty=10000
\widowpenalty=1000
\title{Seminararbeit Traits und Enums in Rust}
\date{}
\author{Mario Occhinegro\\HKA University of Applied Sciences}
\usepackage{setspace}
\onehalfspacing
\singlespacing

\begin{document}
\pagenumbering{gobble} 
\maketitle
\newpage
\clearpage
\tableofcontents
\setcounter{page}{1}
\newpage
\pagenumbering{arabic}
\maketitle
\begin{abstract}
\end{abstract}
\section{Einleitung}
\section{Enums}
\subsection{Enums in Rust}
\subsubsection{Normale Enums}
Enumerationstypen \\
Auf den ersten Blick identisch. \\
Java Enum:
\begin{minted}{rust}
enum Animal {
    Dog,
    Cat,
    Bird,
}
\end{minted}
\subsubsection{Enum mit Werten}
\begin{minted}{rust}
enum Animal {
    Dog,
    Cat,
    Bird,
}

impl Animal{
    fn get_label(&self) -> String{
        match self{
            Animal::Dog => String::from("Dog"),
            Animal::Cat => String::from("Cat"),
            Animal::Bird => String::from("Bird"),
        }
    }

    fn get_weight(&self) -> i32{
        match self{
            Animal::Dog => 20,
            Animal::Cat => 10,
            Animal::Bird => 1,
        }
    }
}

\end{minted}
\subsubsection{Enum mit Funktionen}
\begin{minted}{rust}
enum Animal {
    Dog,
    Cat,
    Bird,
}

impl Animal{
    fn is_cat(&self) -> bool{
        match self{
            Animal::Cat => true,
            Animal::Dog => false,
            Animal::Bird => false
        }
    }
}
\end{minted}
\subsection{Enums in Java}
\begin{itemize}
	\item Enums sind spezielle Klasse
	\item Enumtypen sind Instanzen
	\item Instanz statisch und final (per default)
\end{itemize}
\subsubsection{Normale Enums}
\begin{minted}{java}
enum Animal{
    Dog,
    Cat,
    Bird
}
\end{minted}
\subsubsection{Enums mit Werten}
\begin{minted}{java}
enum Animal{
    Dog("Dog", 20),
    Cat("Dog", 10),
    Bird("Bird", 1);

    public final String label;
    public final int weight;

    private Animal(String label, int weight){
        this.label= label;
        this.weight = weight;
    }
}
\end{minted}
\subsubsection{Enum mit Funktionen}
\begin{minted}{rust}
enum Animal{
    Dog
    Cat
    Bird;

    public boolean isCat(){
        if (this == Animal.Cat){
            return true;
        }else{
            return false;
        }
    }
}
\end{minted}
\begin{minted}{java}
minted\end{minted}
\subsection{Mächtigkeit von Rust Enums}
\subsubsection{Der Enum als algebraischer Datentyp}
- Algebraische Datentypen
\begin{minted}{rust}
fn main() {
    let s1 = Shape::Square(16);
    println!("The area of the shape is {}",s1.area());
}

enum Shape{
    Square(u32),
    Rectangle(u32,u32),
}

impl Shape{
    fn area(&self) -> u32{
        match self {
            Shape::Square(a) => a*a,
            Shape::Rectangle(a,b) => a*b,
        }
    }
}
\end{minted}
\begin{itemize}
	\item beliebige Struktur
	\item werte können sich verändern
		\item flexibel
	\item pattern matching lässt uns die einzelnen Werte benutzen
\end{itemize}
\subsubsection{Generische Enums}
\begin{itemize}
	\item Enums können mit generischen Werten generiert werden
\end{itemize}
\begin{minted}{rust}
enum Option<T> {
	None,
	Some(T),
}
\end{minted}
\subsubsection{Rust Enums und die Vermeidung von Nullpointer-Ausnahmen}
\begin{itemize}
	\item Java hat ähnliches Konzept aber mit Klassen
	\item Nullpointer, der große Milliarden € Fehler
\end{itemize}
\begin{minted}{rust}
mintedfn main() {
    match lookUpAnimal(1){
        Some(Animal::Dog) => println!("Found pet was a dog"),
        Some(_) => println!("Found pet with id 1"),
        None => println!("Sadly no pet was found")
    }
}

enum Animal{
    Dog,
    Cat,
    Bird,
}

fn lookUpAnimal(id: i32) -> Option<Animal>{
    if(id == 1){
        return Some(Animal::Dog);
    }else{
        return None
    }
}
\end{minted}
\subsubsection{Rekursive Enums}
\begin{enumerate}
	\item Box needed
\end{enumerate}
\begin{minted}{rust}
pub enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
}
\end{minted}
\subsubsection{Match Statement}
\begin{minted}{rust}
fn main(){
    let e:Exp = Exp::Plus { 
        left: Box::new(Exp::Int { val: 10 }), right: Box::new(Exp::Int { val: 22})
    };
    println!("Evaluates to: {}", e.eval());
}

pub enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
}

impl Exp{
   fn eval(&self) -> i32{
       match self{
           Exp::Int{val} => *val,
           Exp::Plus{left, right} => left.eval() + right.eval() ,
           Exp::Mult{left, right} => left.eval() * right.eval()
       }
   }
}
\end{minted}
output
\begin{minted}{shell}
minted\end{minted}
\subsubsection{Feste Enum Cases}
\begin{minted}{rust}
fn main(){
    let e:Exp = Exp::Plus { 
        left: Box::new(Exp::Int { val: 10 }), right: Box::new(Exp::Int { val: 22})
    };
    println!("Evaluates to: {}", e.eval());
}
enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
    Div{
        left: Box<Exp>,
        right: Box<Exp>
    }
}

impl Exp{
   fn eval(&self) -> i32{
       match self{
           Exp::Int{val} => *val,
           Exp::Plus{left, right} => left.eval() + right.eval() ,
           Exp::Mult{left, right} => left.eval() * right.eval()
       }
   }
}
pub enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
}

impl Exp{
   fn eval(&self) -> i32{
       match self{
           Exp::Int{val} => *val,
           Exp::Plus{left, right} => left.eval() + right.eval() ,
           Exp::Mult{left, right} => left.eval() * right.eval()
       }
   }
}
\end{minted}
output
\begin{minted}{shell}
error[E0004]: non-exhaustive patterns: `&Exp::Div { .. }` not covered
  --> src/main.rs:27:14
   |
27 |        match self{
   |              ^^^^ pattern `&Exp::Div { .. }` not covered
   |
note: `Exp` defined here
  --> src/main.rs:19:5
   |
7  | pub enum Exp {
   |          ---
...
19 |     Div{
   |     ^^^ not covered
   = note: the matched value is of type `&Exp`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
   |
30 ~            Exp::Mult{left, right} => left.eval() * right.eval(),
31 +            &Exp::Div { .. } => todo!()
   |

For more information about this error, try `rustc --explain E0004`.
\end{minted}
\subsubsection{Nested Pattern Matching}
\begin{itemize}
	\item kann noch granulareres pattern matching betreiben
\end{itemize}
\begin{minted}{rust}
pub enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
}

impl Exp{
   fn eval(&self) -> i32{
       match self{
           Exp::Int{val} => *val,
           Exp::Plus{left, right} => left.eval() + right.eval() ,
           Exp::Mult{left, right} => 
            match **left {
                Exp::Int { val:0 } => return 0,
                _ => return left.eval() * right.eval()
            }
       }
   }
}
\end{minted}
\subsubsection{Erweiterbare Funktionen für Enums}
\begin{minted}{rust}
pub enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
}

impl Exp{
   fn eval(&self) -> i32{
       match self{
           Exp::Int{val} => *val,
           Exp::Plus{left, right} => left.eval() + right.eval() ,
           Exp::Mult{left, right} => left.eval() * right.eval()
       }
   }
   fn treeHeight(&self) -> u32 {
		match self{
           Exp::Int{val} => 1,
           Exp::Plus{left, right} => left.treeHeight() + right.treeHeight(),
           Exp::Mult{left, right} => left.treeHeight() + right.treeHeight(),
		} 
   }
}
\end{minted}
\subsection{Rust-Enum-Funktionalität in Java}
\subsubsection{Switch Case vs Match}

\begin{itemize}
	\item Veränderung des Enums spielt für SC keine Rolle
\item Dieses Verhalten ist auch nicht in Java über tricks Möglich
\item Pattern Matching nur über weitere If/Else Abfragen Möglich
\item nested pattern matching nur über weitere If Else Möglich
\end{itemize}
\subsubsection{Expression-Logik in Java}
Naiver Ansatz (Geht nicht)
\begin{minted}{java}
public class Expression{
    public static void main(String[] args) {
        Exp p = Exp.Plus;
//not accessible
        System.out.println(p.left);
        System.out.println(p.right);
    }
}

enum Exp {
    Int {
        //cannot be changed(static, final)
        int val;

public int eval() {
            return this.val;
        }

    },
    Plus {
        Exp left;
        Exp right;

        public int eval() {
            return this.left.eval() + this.right.eval();
        }
    },
    Mult {
        Exp left;
        Exp right;

        public int eval() {
            return this.left.eval() * this.right.eval();
        }
    };
    

    public abstract int eval();
}

enum ExpTwo{
    Int,
    Plus,
    Mult
}
\end{minted}
Ansatz mit  Klassen
\begin{minted}{java}
public class Expression {
    public static void main(String[] args) {
        System.out.println("test");
    }
}

abstract class Exp{abstract public int eval();}
class IntExp extends Exp{
    public int val;
    public IntExp(int val){
        this.val = val;
    }
    @Override
    public int eval() {
        return val;
    }
}
class PlusExp extends Exp{
    public Exp left;
    public Exp right;
    public PlusExp(Exp left, Exp right){
        this.left = left;
        this.right = right;
    }
    @Override
    public int eval() {
        return left.eval() + right.eval();
    }
}

class MultExp extends Exp{
    public Exp left;
    public Exp right;

    public MultExp(Exp left, Exp right){
        this.left = left;
        this.right = right;
    }

    @Override
    public int eval() {
        return left.eval() * right.eval();
    }
}
\end{minted}
\subsubsection{Vermeidung von Nullpointer-Ausnahmen}
\subsubsection{Java Enums am Limit}
\begin{itemize}
	\item Idee, was aber wenn die Instanz ein Wrapper ist
	\item statische variablen schneiden uns 
\end{itemize}
\begin{minted}{java}
public class EnumLimit{
	public static void main(String[] args) {
		Animal a = Animal.Dog;
		Animal a2 = Animal.Dog;
		Animal b = Animal.Cat;
		System.out.println(a.getObject());
		System.out.println(a2.getObject());
		System.out.println(b.getObject());
		a.setObject("new Dog Value");
		b.setObject("new Cat value");
		System.out.println(a.getObject());
		System.out.println(a.getObject());
		System.out.println(b.getObject());
	}
}

enum Animal{
	Dog(new Wrapper("Doggy")),
	Cat(new Wrapper("Catty"));

	private Wrapper w;
	private Animal(Wrapper w){
		this.w = w;
	}

	public Object getObject(){
		return w.item;
	}
	public void setObject(Object o){
		w.item = o;
	}
}

class Wrapper{
	Object item;

	public Wrapper(Object o){
		item = o;
	}
}
\end{minted}
output
\begin{minted}{shell}
Doggy
Doggy
Catty
new Dog Value
new Dog Value
new Cat value
\end{minted}

\subsection{Traits in Rust}
\begin{enumerate}
	\item geteilte funktionalität mit anderen Typen
	\item Funktionsmenge über einem Typen
	\item Oft mit Interfaces verglichen, sind aber keine Interfaces
	\item interfaces sind Typen
	\item adressieren ähnliche Probleme, traits aber mächtiger
\end{enumerate}
\subsubsection{Einfacher Trait}
\begin{enumerate}
		\item Prädikat auf einem Typen
\end{enumerate}

\begin{minted}{rust}
trait Shape{
    fn area(s: &Self) ->i32;
}

struct Square{
    a: i32
}

impl Shape for Square {
    fn area(s: &Self)->i32{
        s.a*s.a
    }
}

struct Rectangle{
    a: i32,
    b: i32
}

impl Shape for Rectangle {
    fn area(s: &Self)->i32{
        s.a*s.b
    }
}

\end{minted}
\subsubsection{Shorthand Schreibweise}
Andere Schreibweise, so kann man die Funktion auf einer Instanz des Structs aufrufen
\begin{minted}{rust}
trait Shape{
   fn area(&self) -> String;
}

impl Shape for Square{
   fn area(&self) -> i32{
       self.a*self.a
   }
}

fn main() {
   let s = Square{a: 10};
   print!("{}", s.area());
}
\end{minted}
\subsubsection{Default-Implementationen}
\begin{enumerate}
	\item geht in java auch
\end{enumerate}
\begin{minted}{rust}
fn main() {
    let c1:Cat  = Cat{};
    Animal::makeNoise(&c1);
}

trait Animal{
    fn makeNoise(s: &Self){
        println!("The Animal made a noise");
    }
}
struct Cat{}
impl Animal for Cat{}
\end{minted}
When running main yields
\begin{minted}{shell}
The Animal made a noise
\end{minted}
\subsubsection{Trait Bounds}
\begin{minted}{rust}
//Das Shape Prädikat muss für A und für B gelten
fn sum_area<A:Shape,B:Shape>(x : &A, y : &B) -> i32 {
    return area(x) + area(y)
 }
\end{minted}
\subsubsection{Multiples Binding}
Man kann auch Prädikate/Traits verunden
\begin{minted}{rust}
fn sum_area<A:Shape+OtherTraits>(x : &+OtherTraits) -> i32 {
	...
 }
\end{minted}
\subsubsection{Dynamische Traits}
Repräsentieren von Interfaces in Rust \\
Können Konkrete Typen als Parameter und Rückgabewerte nutzen
\begin{minted}{rust}
fn sum_area(x : Box<dyn Shape>, y: Box<dyn Shape>) -> i32 {
    return area(x) + area(y)
 }
\end{minted}
\subsubsection{Kurzschreibweise für dynamische Traits}
\begin{minted}{rust}
fn sum_area(x : &(impl Shape), y: &(impl Shape)) -> i32 {
    return area(x) + area(y)
 }
\end{minted}
\subsubsection{Platzhaltertypen}
\begin{minted}{rust}
fn main(){
    let m = Machine{};
    let a: i8 = 16;
    let b: i32 = TransformAB::transform(&m, a);
}
trait TransformAB{
    type A;
    type B;
    fn transform(s: &Self, a: Self::A) -> Self::B;
}

struct Machine{}
impl TransformAB for Machine{
    type A = i8;
    type B = i32;
    fn transform(s: &Self, a: Self::A) -> Self::B {
        i32::from(a)
    }
}
\end{minted}
\subsubsection{Assoziierte Konstanten}
\begin{minted}{rust}
fn main(){
    let m = Machine{};
    let a: i8 = 16;
    let b: Vec<i32> = TransformAB::transform(&m, a);
}
trait TransformAB{
    type A;
    type B;
    const TIMES: u8;
    fn transform(s: &Self, a: Self::A) -> Vec<Self::B>;
}

struct Machine{}
impl TransformAB for Machine{
    type A = i8;
    type B = i32;
    const TIMES:u8 = 50;
    fn transform(s: &Self, a: Self::A) -> Vec<Self::B>{
        let mut v = Vec::new();
        let a32 = i32::from(a);
        for i in 0..Self::TIMES  {
            v.push(a32);
        }
        v
    }
}
\end{minted}
\subsubsection{Supertraits}
\begin{itemize}
	\item man kann hirarchie nachbauen
\end{itemize}
\begin{minted}{rust}
fn main() {
    let s = HskaStudent{name:"Mario", university:"hska", fav_language:"rust", git_username:"yellow-tshirt"};
    comp_sci_student_greeting(&s);
}
trait Person {
    fn name(&self) -> String;
}
trait Student: Person {
    fn university(&self) -> String;
}
trait Programmer {
    fn fav_language(&self) -> String;
}
trait CompSciStudent: Programmer + Student {
    fn git_username(&self) -> String;
}
fn comp_sci_student_greeting<S: CompSciStudent>(student: &S) {
    println!("Hey my name is {}, I study at {}. My favorite language is {} and my git username is {}", student.name(), student.university(), student. fav_language(), student.git_username());
}
struct HskaStudent{
    name: &'static str,
    university: &'static str,
    fav_language: &'static str,
    git_username: &'static str,
}
impl Person for HskaStudent{
    fn name(&self) -> String{
        self.name.to_string()
    }
}
impl Student for HskaStudent{
    fn university(&self) -> String {
        String::from(self.university)
    }
}

impl Programmer for HskaStudent{
    fn fav_language(&self) -> String{
        String::from(self.fav_language)
    }
}
impl CompSciStudent for HskaStudent{
    fn git_username(&self) -> String {
        String::from(self.git_username)
    }
}
\end{minted}
\subsection{Mächtigkeit von Traits}
\subsubsection{Gleiche Methodensignatur}
- kurzschreibweise geht hier nicht
\begin{minted}{rust}
fn main() {
   let x = some_struct{};
   musicplayer::play(&x);
   boardgame::stop(&x);
}

struct some_struct{}

trait musicplayer{
    fn play(s: &Self);
    fn stop(&self);
}
trait boardgame{
    fn play(s: &Self);
    fn stop(&self);
}

impl musicplayer for some_struct {
  fn play(s: &Self) {
      println!("Playing music");
  }
  fn stop(&self) {
      println!("Stopping music");
  }
}
impl boardgame for some_struct {
  fn play(s: &Self) {
      println!("Playing boardgame");
  }
  fn stop(&self) {
      println!("Stopping boardgame");
  }
}
\end{minted}
\subsubsection{Generische Mehrfachimplementierung}
\begin{minted}{rust}
fn main() {
    let s : some_struct = some_struct{};
    let someInteger: i32 = s.mygenval();
    let someString: String = s.mygenval();
}
struct some_struct{}

trait generic<T>{
   fn mygenval(&self) -> T;
}

impl generic<i32> for some_struct {
   fn mygenval(&self) -> i32{
       5
   }
}

impl generic<String> for some_struct {
   fn mygenval(&self) -> String{
       "abc".to_string()
   }
}
\end{minted}
\subsubsection{Referenzierung des eigenen Typen}
\begin{minted}{rust}
trait genCopy{
    fn genCopy(s: &Self) -> Self;
}

struct Dog{
    name: String,
    age: u8,
}
struct Cat{
    name: String,
    age: u8,
}

impl genCopy for Dog{
    fn genCopy(s: &Self) -> Self {
        return Dog{name: s.name.clone(), age: s.age};
    }
}
impl genCopy for Cat{
    fn genCopy(s: &Self) -> Self {
        return Cat{name: s.name.clone(), age: s.age};
    }
}
\end{minted}
\subsubsection{Funktionalität für Third-Party-Datentypen}
\begin{minted}{rust}
use std::thread;
use std::time::Duration;

fn main() {
    thiryparty_struct{}.sleep();
}
struct thiryparty_struct{}

trait Sleep{
    fn sleep(&self);
}

impl Sleep for thiryparty_struct {
    fn sleep(&self){
        thread::sleep(Duration::from_millis(1000));
    }
}
\end{minted}
\subsubsection{Konditionelle Implementierung}
\begin{minted}{rust}
struct Pair<T> {
    x: T,
    y: T,
}

struct dog{
    name: String,
    age: u8,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
\end{minted}
\subsection{Traitfunktionalität in Java}
\subsubsection{Gleiche Methodensignatur}
Geht nicht, weil nicht eindeutig (Signaturkonflikt)
\begin{minted}{java}
class SomeClass implements musicplayer, boardgame{
   public void play(){
       System.out.println("You are playing");
   }
}
interface musicplayer{
   public void play();
}
interface boardgame{
   public void play();
}
\end{minted}
\paragraph{Lösung via Adapterpattern}
\begin{minted}{java}
public class AdapterCompatible {
    public static void main(String[] args) {
        SomeClass sc = new SomeClass();
        MusicPlayerAdapter ma = new MusicPlayerAdapter(sc);
        BoardGameAdapter ba = new BoardGameAdapter(sc);
        ma.play();
        ba.play();
    }
}
class SomeClass{
    public void playMusic(){
        System.out.println("Playing music");
    }
    public void playBoardGame(){
        System.out.println("Playing boardgame");
    }
}
interface MusicPlayer{
    public void play();
}
interface BoardGame{
    public void play();
}

class MusicPlayerAdapter implements MusicPlayer {
    private SomeClass someClass;
    
    public MusicPlayerAdapter(SomeClass someClass) {
        this.someClass = someClass;
    }
    @Override
    public void play() {
        someClass.playMusic();
    }
}

class BoardGameAdapter implements BoardGame {
    private SomeClass someClass;
    
    public BoardGameAdapter(SomeClass someClass) {
        this.someClass = someClass;
    }
    @Override
    public void play() {
        someClass.playBoardGame();
    }
}
\end{minted}
\subsubsection{Generische Mehrfachimplementierung}
- Interface kann nicht mehr als einmal implementiert werden
- Wieder Adapter
\begin{minted}{java}
public class SomeClass implements Generic<Integer>, Generic<String> {
    public static void main(String[] args) {
        SomeClass sc = new SomeClass();
    }
}

interface Generic<T> {
    public T mygenvalue();
}
\end{minted}
output
\begin{minted}{shell}
SomeClass.java:1: error: Generic cannot be inherited with
different arguments: <java.lang.Integer> and <java.lang.String>
\end{minted}
\paragraph{Lösung}
\begin{minted}{java}
public class SomeClass {
    public static void main(String[] args) {
        SomeClass sc = new SomeClass();
        Integer someInt = new GenericIntAdapter(sc).mygenvalue();
        String someString = new GenericStringAdapter(sc).mygenvalue();
    }
}

interface Generic<T> {
    public T mygenvalue();
}

class GenericIntAdapter implements Generic<Integer> {
    private SomeClass someClass;

    public GenericIntAdapter(SomeClass someClass) {
        this.someClass = someClass;
    }

    @Override
    public Integer mygenvalue() {
        return 5;
    }
}
class GenericStringAdapter implements Generic<String> {
    private SomeClass someClass;

    public GenericStringAdapter(SomeClass someClass){
        this.someClass = someClass;
    }
    @Override
    public String mygenvalue() {
        return "abc";
    }
}
\end{minted}
\subsubsection{Funktionalität für Third-Party-Datentypen}
\begin{minted}{java}
public class ThirdParty {
    public static void main(String[] args) {
        ThirdParty original = new ThirdParty();
        WrapperClass wrapper = new WrapperClass(original);

        wrapper.doSomething();
        wrapper.sleep();
        wrapper.doSomething();
    }
    public void doSomething() {
        System.out.println("Doing something...");
    }
}

class WrapperClass {
    private ThirdParty original;

    public WrapperClass(ThirdParty original) {
        this.original = original;
    }

    public void doSomething() {
        original.doSomething();
    }

    public void sleep() {
        try {
            Thread.sleep(1000); // Sleep for 1000 milliseconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
\end{minted}
\subsubsection{Konditionelle Implementierung}
\section{Vergleich}
\subsection{Enums}
\begin{itemize}
	\item Enums kombiniert mit Klassen kann Alle Enums nachbauen
\end{itemize}
\subsection{Traits}

\bibliographystyle{plain}
\bibliography{bib}

\end{document}\documentclass[a5paper, 1ppt]{article}
