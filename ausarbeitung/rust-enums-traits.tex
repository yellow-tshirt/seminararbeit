\documentclass[a4paper, 1ppt]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage[german]{babel}
\usepackage{abstract}
\usepackage{url}
\usepackage{hyperref}
\usepackage{hyphenat}
\usepackage{minted}
\clubpenalty=10000
\widowpenalty=1000
\title{Seminararbeit Traits und Enums in Rust}
\date{}
\author{Mario Occhinegro\\HKA University of Applied Sciences}
\usepackage{setspace}
\onehalfspacing
\singlespacing

\begin{document}
\pagenumbering{gobble} 
\maketitle
\newpage
\clearpage
\tableofcontents
\setcounter{page}{1}
\newpage
\pagenumbering{arabic}
\maketitle
\begin{abstract}
\end{abstract}
\section{Einleitung}
\section{Enums}
Enumerationstypen \\
Auf den ersten Blick identisch. \\
Java Enum:
\begin{minted}{java}
enum Color{
    red,
    green,
    blue;
}
\end{minted}
Rust Enum:
\begin{minted}{rust}
enum Animal {
    Dog,
    Cat,
    Bird,
}
\end{minted}
Auf Konkretere Unterschiede gehen wir jetzt ein
\subsection{Enums in Rust}
- Algebraische Datentypen
\subsubsection{Match Statement}
\begin{itemize}
	\item abgeschlossen
	\item an Haskell angelehnt
	\item mehr als nur if else
	\item sehr ergonomisch, aussagekräftig und kurz
\end{itemize}
\begin{minted}{rust}
fn main() {
	let a1 = Animal::Dog;
	match a1{
		Animal::Dog => println!("It's a Dog"),
		Animal::Cat => println!("It's a Cat"),
		Animal::Bird => println!("It's a Bird")
	}
}

enum Animal{
	Dog,
	Cat,
	Bird
}
\end{minted}
\subsubsection{Der Enum als algebraischer Datentyp}
\begin{itemize}
	\item beliebige Struktur
	\item werte können sich verändern
	\item flexibel
	\item pattern matching lässt uns die einzelnen Werte benutzen
\end{itemize}
\begin{minted}{rust}
fn main() {
    let s1 = Shape::Square(16);
    println!("The area of the shape is {}",s1.area());
}

enum Shape{
    Square(u32),
    Rectangle(u32,u32),
}

impl Shape{
    fn area(&self) -> u32{
        match self {
            Shape::Square(a) => a*a,
            Shape::Rectangle(a,b) => a*b,
        }
    }
}
\end{minted}
\subsubsection{Rekusive Enums und Datentypen}
\begin{itemize}
	\item braucht Box (wie Zeiger)
	\item Box sonst, rekursive Definition ohne Direktion
\end{itemize}
\begin{minted}{rust}
enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
}

impl Exp{
    fn eval(&self) -> i32{
        match self{
            Exp::Int{val} => *val,
            Exp::Plus{left, right} => left.eval() + right.eval() ,
            Exp::Mult{left, right} => left.eval() + right.eval()

        }
    }
}
\end{minted}
\subsubsection{Nested Pattern Matching}
\begin{itemize}
	\item kann noch granulareres pattern matching betreiben
\end{itemize}
\begin{minted}{rust}
pub enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
}

impl Exp{
   fn eval(&self) -> i32{
       match self{
           Exp::Int{val} => *val,
           Exp::Plus{left, right} => left.eval() + right.eval() ,
           Exp::Mult{left, right} => 
            match **left {
                Exp::Int { val:0 } => return 0,
                _ => return left.eval() * right.eval()
            }
       }
   }
}
\end{minted}
\subsubsection{Generische Enums}
\begin{itemize}
	\item Enums können mit generischen Werten generiert werden
\end{itemize}
\begin{minted}{rust}
enum Option<T> {
	None,
	Some(T),
}
\end{minted}
\subsubsection{Verwendung des Rust Enums zur Vermeidung von Nullpointer-Ausnahmen}
\begin{itemize}
	\item Java hat ähnliches Konzept aber mit Klassen
	\item Nullpointer, der große Milliarden € Fehler
\end{itemize}
\begin{minted}{rust}
mintedfn main() {
    match lookUpAnimal(1){
        Some(Animal::Dog) => println!("Found pet was a dog"),
        Some(_) => println!("Found pet with id 1"),
        None => println!("Sadly no pet was found")
    }
}

enum Animal{
    Dog,
    Cat,
    Bird,
}

fn lookUpAnimal(id: i32) -> Option<Animal>{
    if(id == 1){
        return Some(Animal::Dog);
    }else{
        return None
    }
}
\end{minted}
\subsection{Enums in Java}
\begin{itemize}
	\item Enums sind spezielle Klasse
	\item Enumtypen sind Instanzen
	\item Instanz statisch und final (per default)
\end{itemize}
\subsubsection{Normale Enums}
\begin{minted}{java}
enum Animal{
    Dog,
    Cat,
    Bird
}
\end{minted}
\subsubsection{Enums mit Werten}
\begin{minted}{java}
enum AnimalWithValues{
    Dog("Dog", 20),
    Cat("Dog", 10),
    Bird("Bird", 1);

    public final String label;
    public final int weight;

    //constructor
    private AnimalWithValues(String label, int weight){
        this.label= label;
        this.weight = weight;
    }
}
\end{minted}
\subsubsection{Enum Funktionen}
\begin{minted}{java}
minted\end{minted}
\subsection{Vergleich von Java und Rust Enums}
\subsection{Rust Enum Implementationsbeispiele}
\subsubsection{}
\subsection{Beispielfunktionalität in Java}
\subsubsection{Expression-Logik in Java}
Naiver Ansatz
\begin{minted}{java}
public class Expression{
    public static void main(String[] args) {
        Exp p = Exp.Plus;
//not accessible
        System.out.println(p.left);
        System.out.println(p.right);
    }
}

enum Exp {
    Int {
        //cannot be changed(static, final)
        int val;

public int eval() {
            return this.val;
        }

    },
    Plus {
        Exp left;
        Exp right;

        public int eval() {
            return this.left.eval() + this.right.eval();
        }
    },
    Mult {
        Exp left;
        Exp right;

        public int eval() {
            return this.left.eval() * this.right.eval();
        }
    };
    

    public abstract int eval();
}

enum ExpTwo{
    Int,
    Plus,
    Mult
}
\end{minted}
Ansatz mit  Klassen
\begin{minted}{java}
public class Expression {
    public static void main(String[] args) {
        System.out.println("test");
    }
}

abstract class Exp{abstract public int eval();}
class IntExp extends Exp{
    public int val;
    public IntExp(int val){
        this.val = val;
    }
    @Override
    public int eval() {
        return val;
    }
}
class PlusExp extends Exp{
    public Exp left;
    public Exp right;
    public PlusExp(Exp left, Exp right){
        this.left = left;
        this.right = right;
    }
    @Override
    public int eval() {
        return left.eval() + right.eval();
    }
}

class MultExp extends Exp{
    public Exp left;
    public Exp right;

    public MultExp(Exp left, Exp right){
        this.left = left;
        this.right = right;
    }

    @Override
    public int eval() {
        return left.eval() * right.eval();
    }
}
\end{minted}
\subsubsection{Java Enums am Limit - Idee einer Wrapperinstanz für den Typ}
\begin{itemize}
	\item Idee, was aber wenn die Instanz ein Wrapper ist
	\item nicht sehr ergonomisch 
	\item statische variablen schneiden uns 
\end{itemize}
\begin{minted}{java}
mintedpublic class playground{
	public static void main(String[] args) {
		Animal a = Animal.Dog;
		Animal a2 = Animal.Dog;
		Animal b = Animal.Cat;
		System.out.println(a.getObject());
		System.out.println(a2.getObject());
		System.out.println(b.getObject());
		a.setObject("new Dog Value");
		b.setObject("new Cat value");
		System.out.println(a.getObject());
		System.out.println(a.getObject());
		System.out.println(b.getObject());
	}
}

enum Animal{
	Dog(new Wrapper("Doggy")),
	Cat(new Wrapper("Catty"));

	private Wrapper w;
	private Animal(Wrapper w){
		this.w = w;
	}

	public Object getObject(){
		return w.item;
	}
	public void setObject(Object o){
		w.item = o;
	}
}

class Wrapper{
	Object item;

	public Wrapper(Object o){
		item = o;
	}
}
\end{minted}
output
\begin{minted}{shell}
Doggy
Doggy
Catty
new Dog Value
new Dog Value
new Cat value
\end{minted}
\section{Traits}
\subsection{Allgemeines zu Traits}
\begin{enumerate}
	\item geteilte funktionalität mit anderen Typen
	\item Funktionsmenge über einem Typen
	\item Oft mit Interfaces verglichen, sind aber keine Interfaces
	\item interfaces sind Typen
	\item adressieren ähnliche Probleme, traits aber mächtiger
\end{enumerate}
\subsubsection{Traits sind keine Typen}
\subsection{Traits in Rust}
\begin{enumerate}
		\item Prädikat auf einem Typen
\end{enumerate}

\begin{minted}{rust}
mintedtrait Shape{
    fn area(s: &Self) ->i32;
}

struct Square{
    a: i32
}

impl Shape for Square {
    fn area(s: &Self)->i32{
        s.a*s.a
    }
}

struct Rectangle{
    a: i32,
    b: i32
}

impl Shape for Rectangle {
    fn area(s: &Self)->i32{
        s.a*s.b
    }
}

\end{minted}
\subsubsection{Default-Implementationen}
\begin{enumerate}
	\item geht in java auch
\end{enumerate}
\begin{minted}{rust}
fn main() {
    let c1:Cat  = Cat{};
    Animal::makeNoise(&c1);
}

trait Animal{
    fn makeNoise(s: &Self){
        println!("The Animal made a noise");
    }
}
struct Cat{}
impl Animal for Cat{}
\end{minted}
When running main yields
\begin{minted}{shell}
The Animal made a noise
\end{minted}
\subsubsection{Trait Bounds}
\begin{minted}{rust}
//Das Shape Prädikat muss für A und für B gelten
fn sum_area<A:Shape,B:Shape>(x : &A, y : &B) -> i32 {
    return area(x) + area(y)
 }
\end{minted}
\subsubsection{Multiples Binding}
Man kann auch Prädikate/Traits verunden
\begin{minted}{rust}
fn sum_area<A:Shape+OtherTraits>(x : &+OtherTraits) -> i32 {
	...
 }
\end{minted}
\subsubsection{Konditionelle Implementierung mit Trait Bounds}
\begin{minted}{rust}
struct Pair<T> {
    x: T,
    y: T,
}

struct dog{
    name: String,
    age: u8,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
\end{minted}
\subsubsection{Dynamische Traits}
Repräsentieren von Interfaces in Rust \\
Können Konkrete Typen als Parameter und Rückgabewerte nutzen
\begin{minted}{rust}
fn sum_area(x : Box<dyn Shape>, y: Box<dyn Shape>) -> i32 {
    return area(x) + area(y)
 }
\end{minted}
\subsubsection{Kurzschreibweise für dynamische Traits}
\begin{minted}{rust}
fn sum_area(x : &(impl Shape), y: &(impl Shape)) -> i32 {
    return area(x) + area(y)
 }
\end{minted}
\subsubsection{Where Clause}
\subsubsection{Supertraits}
\begin{itemize}
	\item man kann hirarchie nachbauen
\end{itemize}
\begin{minted}{rust}
fn main() {
    let s = hskaStudent{name:"Mario", university:"hska", fav_language:"rust", git_username:"myusername"};
    comp_sci_student_greeting(s);
}

trait Person {
    fn name(&self) -> String;
}

trait Student: Person {
    fn university(&self) -> String;
}

trait Programmer {
    fn fav_language(&self) -> String;
}
trait CompSciStudent: Programmer + Student {
    fn git_username(&self) -> String;
}

fn comp_sci_student_greeting<s: CompSciStudent>(student: s) {
    ...
}

struct hskaStudent{
    name: &'static str,
    university: &'static str,
    fav_language: &'static str,
    git_username: &'static str,
}

impl Person for hskaStudent{
    fn name(&self) -> String{
        self.name.to_string()
    }
}

impl Student for hskaStudent{
    fn university(&self) -> String {
       self.university().to_string() 
    }
}
\end{minted}
\subsubsection{Referenzierung des eigenen Typen}
\subsubsection{Spezifizierung von Platzhaltertypen}
\subsubsection{Shorthand Schreibweise}
\subsubsection{Schreibeweise bei Uneindeutigkeit}
\subsection{Rust Trait Beispiele}
\subsection{Beispielfunktionalität in Java}
\section{Vergleich der beiden Ansätze}

\bibliographystyle{plain}
\bibliography{bib}

\end{document}\documentclass[a5paper, 1ppt]{article}
