\documentclass[a4paper, 1ppt]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage[german]{babel}
\usepackage{abstract}
\usepackage{url}
\usepackage{hyperref}
\usepackage{hyphenat}
\usepackage{minted}
\clubpenalty=10000
\widowpenalty=1000
\title{Seminararbeit Traits und Enums in Rust}
\date{}
\author{Mario Occhinegro\\HKA University of Applied Sciences}
\usepackage{setspace}
\onehalfspacing
\singlespacing

\begin{document}
\pagenumbering{gobble} 
\maketitle
\newpage
\clearpage
\tableofcontents
\setcounter{page}{1}
\newpage
\pagenumbering{arabic}
\maketitle
\begin{abstract}
\end{abstract}
\section{Einleitung}
\section{Enums}
Enumerationstypen \\
Auf den ersten Blick identisch. \\
Java Enum:
\begin{minted}{java}
enum Color{
    red,
    green,
    blue;
}
\end{minted}
Rust Enum:
\begin{minted}{rust}
enum Animal {
    Dog,
    Cat,
    Bird,
}
\end{minted}
Auf Konkretere Unterschiede gehen wir jetzt ein
\subsection{Enums in Rust}
- Algebraische Datentypen
\subsubsection{Match Statement}
\begin{itemize}
	\item abgeschlossen
	\item an Haskell angelehnt
	\item mehr als nur if else
	\item sehr ergonomisch, aussagekräftig und kurz
\end{itemize}
\begin{minted}{rust}
fn main() {
	let a1 = Animal::Dog;
	match a1{
		Animal::Dog => println!("It's a Dog"),
		Animal::Cat => println!("It's a Cat"),
		Animal::Bird => println!("It's a Bird")
	}
}

enum Animal{
	Dog,
	Cat,
	Bird
}
\end{minted}
\subsubsection{Der Enum als algebraischer Datentyp}
\begin{itemize}
	\item beliebige Struktur
	\item werte können sich verändern
	\item flexibel
	\item pattern matching lässt uns die einzelnen Werte benutzen
\end{itemize}
\begin{minted}{rust}
fn main() {
    let s1 = Shape::Square(16);
    println!("The area of the shape is {}",s1.area());
}

enum Shape{
    Square(u32),
    Rectangle(u32,u32),
}

impl Shape{
    fn area(&self) -> u32{
        match self {
            Shape::Square(a) => a*a,
            Shape::Rectangle(a,b) => a*b,
        }
    }
}
\end{minted}
\subsubsection{Rekusive Enums und Datentypen}
\begin{itemize}
	\item braucht Box (wie Zeiger)
	\item Box sonst, rekursive Definition ohne Direktion
\end{itemize}
\begin{minted}{rust}
enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
}

impl Exp{
    fn eval(&self) -> i32{
        match self{
            Exp::Int{val} => *val,
            Exp::Plus{left, right} => left.eval() + right.eval() ,
            Exp::Mult{left, right} => left.eval() + right.eval()

        }
    }
}
\end{minted}
\subsubsection{Nested Pattern Matching}
\begin{itemize}
	\item kann noch granulareres pattern matching betreiben
\end{itemize}
\begin{minted}{rust}
pub enum Exp {
    Int {
        val: i32
    },
    Plus {
        left: Box<Exp>,
        right: Box<Exp>
    },
    Mult{
        left: Box<Exp>,
        right: Box<Exp>
    },
}

impl Exp{
   fn eval(&self) -> i32{
       match self{
           Exp::Int{val} => *val,
           Exp::Plus{left, right} => left.eval() + right.eval() ,
           Exp::Mult{left, right} => 
            match **left {
                Exp::Int { val:0 } => return 0,
                _ => return left.eval() * right.eval()
            }
       }
   }
}
\end{minted}
\subsubsection{Generische Enums}
\begin{itemize}
	\item Enums können mit generischen Werten generiert werden
\end{itemize}
\begin{minted}{rust}
enum Option<T> {
	None,
	Some(T),
}
\end{minted}
\subsubsection{Verwendung des Rust Enums zur Vermeidung von Nullpointer-Ausnahmen}
\begin{itemize}
	\item Java hat ähnliches Konzept aber mit Klassen
	\item Nullpointer, der große Milliarden € Fehler
\end{itemize}
\begin{minted}{rust}
mintedfn main() {
    match lookUpAnimal(1){
        Some(Animal::Dog) => println!("Found pet was a dog"),
        Some(_) => println!("Found pet with id 1"),
        None => println!("Sadly no pet was found")
    }
}

enum Animal{
    Dog,
    Cat,
    Bird,
}

fn lookUpAnimal(id: i32) -> Option<Animal>{
    if(id == 1){
        return Some(Animal::Dog);
    }else{
        return None
    }
}
\end{minted}
\subsection{Enums in Java}
\begin{itemize}
	\item Enums sind Instanzen
	\item Instanz statisch und final (per default)
\end{itemize}
\subsubsection{Normale Enums}
\subsubsection{Enums mit Werten}
\subsubsection{Enum Funktionen}
\subsection{Vergleich von Java und Rust Enums}
\subsection{Rust Enum Implementationsbeispiele}
\subsection{Beispielfunktionalität in Java}
\subsubsection{Expression-Logik in Java}
\subsubsection{Java Enums am Limit - Idee einer Wrapperinstanz für den Typ}
\begin{itemize}
	\item Idee, was aber wenn die Instanz ein Wrapper ist
	\item nicht sehr ergonomisch 
	\item statische variablen schneiden uns 
\end{itemize}
\begin{minted}{java}
mintedpublic class playground{
	public static void main(String[] args) {
		Animal a = Animal.Dog;
		Animal a2 = Animal.Dog;
		Animal b = Animal.Cat;
		System.out.println(a.getObject());
		System.out.println(a2.getObject());
		System.out.println(b.getObject());
		a.setObject("new Dog Value");
		b.setObject("new Cat value");
		System.out.println(a.getObject());
		System.out.println(a.getObject());
		System.out.println(b.getObject());
	}
}

enum Animal{
	Dog(new Wrapper("Doggy")),
	Cat(new Wrapper("Catty"));

	private Wrapper w;
	private Animal(Wrapper w){
		this.w = w;
	}

	public Object getObject(){
		return w.item;
	}
	public void setObject(Object o){
		w.item = o;
	}
}

class Wrapper{
	Object item;

	public Wrapper(Object o){
		item = o;
	}
}
\end{minted}
output
\begin{minted}{shell}
Doggy
Doggy
Catty
new Dog Value
new Dog Value
new Cat value
\end{minted}
\section{Traits}
\subsection{Allgemeines zu Traits}
\subsubsection{Traits sind keine Typen}
\subsection{Traits in Rust}
\subsubsection{Default-Implementationen}
\subsubsection{Trait Bounds}
\paragraph{Mehrfaches Traitbinding}
\paragraph{Konditionelle Implementierung mit Trait Bounds}
\subsubsection{Dynamische Traits}
\subsubsection{Traits als Parameter}
wie interfaces
\subsubsection{Supertraits}
\subsubsection{Referenzierung des eigenen Typen}
\subsubsection{Spezifizierung von Platzhaltertypen}
\subsubsection{Shorthand Schreibweise}
\subsubsection{Schreibeweise bei Uneindeutigkeit}
\subsection{Rust Trait Beispiele}
\subsection{Beispielfunktionalität in Java}
\section{Vergleich der beiden Ansätze}

\bibliographystyle{plain}
\bibliography{bib}

\end{document}\documentclass[a4paper, 1ppt]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage[german]{babel}
\usepackage{abstract}
\usepackage{url}
\usepackage{hyperref}
\usepackage{hyphenat}
\usepackage{minted}
\clubpenalty=10000
\widowpenalty=1000
\title{Seminararbeit Traits und Enums in Rust}
\date{}
\author{Mario Occhinegro\\HKA University of Applied Sciences}
\usepackage{setspace}
\onehalfspacing
\singlespacing

\begin{document}
\pagenumbering{gobble} 
\maketitle
\newpage
\clearpage
\tableofcontents
\setcounter{page}{1}
\newpage
\pagenumbering{arabic}
\maketitle
\begin{abstract}
		    Something
	\end{abstract}
	\section{Einleitung}
	Eines der faszinierendsten Aspekte der Programmiersprachen Rust und Java ist ihre unterschiedliche Herangehensweise an die Modellierung von Datenstrukturen und Verhaltensweisen. In diesem Vergleich werden wir uns insbesondere auf die Konzepte der Enums und Traits in beiden Sprachen konzentrieren. Enums ermöglichen es, benutzerdefinierte Datentypen zu definieren, die eine begrenzte Anzahl von möglichen Werten repräsentieren, während Traits die Möglichkeit bieten, Verhaltensweisen zu abstrahieren und zu wiederverwenden.

	Wir werden sowohl die Gemeinsamkeiten als auch die Unterschiede zwischen Rust und Java in Bezug auf Enums und Traits analysieren. Dabei betrachten wir die Syntax, die Flexibilität, die Typsicherheit und die Einsatzmöglichkeiten dieser Konzepte in beiden Sprachen. Ziel ist es, ein umfassendes Verständnis dafür zu entwickeln, wie Enums und Traits in Rust und Java genutzt werden können und welche Vor- und Nachteile sie bieten.

	Indem wir die Besonderheiten von Rusts Enums und Traits mit denen von Javas Entsprechungen vergleichen, erhalten wir Einblicke in die unterschiedlichen Paradigmen, die hinter den beiden Sprachen stehen. Dieser Vergleich ermöglicht es Entwicklern, ihre Entscheidungen bei der Wahl einer geeigneten Sprache für bestimmte Projekte besser zu treffen und ihre Kenntnisse über die Konzepte der Enums und Traits in Rust und Java zu erweitern.
	\section{Enums}
	Enums, oder auch Aufzählungstypen, sind spezielle Datentypen in der Programmierung, die eine begrenzte Menge von benannten Werten repräsentieren. Sie ermöglichen es, eine feste Liste von möglichen Optionen zu definieren, aus denen ein Wert ausgewählt werden kann. Enums werden häufig verwendet, um eine klar definierte Menge von Zuständen, Typen oder Optionen darzustellen, die in einem Programm oder einer Anwendung auftreten können.

	Durch die Verwendung von Enums können Programmierer den Code lesbarer und verständlicher machen, da die verwendeten Werte klar benannt sind und eine eindeutige Bedeutung haben. Enums bieten auch eine verbesserte Typsicherheit, da der Compiler sicherstellen kann, dass nur gültige Werte eines Enums verwendet werden.

	Enums können in verschiedenen Programmiersprachen implementiert werden und weisen je nach Sprache unterschiedliche Funktionalitäten auf. In einigen Sprachen können Enums beispielsweise mit zu
